<!--
 ~ Licensed to the Apache Software Foundation (ASF) under one
 ~ or more contributor license agreements.  See the NOTICE file
 ~ distributed with this work for additional information
 ~ regarding copyright ownership.  The ASF licenses this file
 ~ to you under the Apache License, Version 2.0 (the
 ~ "License"); you may not use this file except in compliance
 ~ with the License.  You may obtain a copy of the License at
 ~
 ~    http://www.apache.org/licenses/LICENSE-2.0
 ~
 ~ Unless required by applicable law or agreed to in writing,
 ~ software distributed under the License is distributed on an
 ~ "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 ~ KIND, either express or implied.  See the License for the
 ~ specific language governing permissions and limitations
 ~ under the License.
-->
<Storage>
  <!--======================================================================-->
  <!-- Basic Configuration                                                  -->
  <!--======================================================================-->

  <!-- 
   ~ The name of this cluster.  This is mainly used to prevent machines in
   ~ one logical cluster from joining another.
  -->
  <ClusterName>myMed cluster</ClusterName>

  <!--
   ~ Turn on to make new [non-seed] nodes automatically migrate the right data 
   ~ to themselves.  (If no InitialToken is specified, they will pick one 
   ~ such that they will get half the range of the most-loaded node.)
   ~ If a node starts up without bootstrapping, it will mark itself bootstrapped
   ~ so that you can't subsequently accidently bootstrap a node with
   ~ data on it.  (You can reset this by wiping your data and commitlog
   ~ directories.)
   ~
   ~ Off by default so that new clusters and upgraders from 0.4 don't
   ~ bootstrap immediately.  You should turn this on when you start adding
   ~ new nodes to a cluster that already has data on it.  (If you are upgrading
   ~ from 0.4, start your cluster with it off once before changing it to true.
   ~ Otherwise, no data will be lost but you will incur a lot of unnecessary
   ~ I/O before your cluster starts up.)
  -->
  <AutoBootstrap>false</AutoBootstrap>

  <!--
   ~ See http://wiki.apache.org/cassandra/HintedHandoff
  -->
  <HintedHandoffEnabled>true</HintedHandoffEnabled>

  <!--
   ~ The Index Interval determines the rate of sampling of row keys
   ~ is for a given SSTable: 1/IndexInterval keys are held in memory
   ~ for the lifetime of the sstable for use during key lookup.
   ~ (This is separate from the KeyCache.)  Larger intervals will result
   ~ in lower memory usage at the cost of slower row lookup at read time.
  -->
  <IndexInterval>128</IndexInterval>

  <!--
   ~ Keyspaces and ColumnFamilies:
   ~ A ColumnFamily is the Cassandra concept closest to a relational
   ~ table.  Keyspaces are separate groups of ColumnFamilies.  Except in
   ~ very unusual circumstances you will have one Keyspace per application.

   ~ There is an implicit keyspace named 'system' for Cassandra internals.
  -->
      <!--
       ~ ColumnFamily definitions have one required attribute (Name)
       ~ and several optional ones.
       ~
       ~ The CompareWith attribute tells Cassandra how to sort the columns
       ~ for slicing operations.  The default is BytesType, which is a
       ~ straightforward lexical comparison of the bytes in each column.
       ~ Other options are AsciiType, UTF8Type, LexicalUUIDType, TimeUUIDType,
       ~ and LongType.  You can also specify the fully-qualified class
       ~ name to a class of your choice extending
       ~ org.apache.cassandra.db.marshal.AbstractType.
       ~ 
       ~ SuperColumns have a similar CompareSubcolumnsWith attribute.
       ~ 
       ~ BytesType: Simple sort by byte value.  No validation is performed.
       ~ AsciiType: Like BytesType, but validates that the input can be 
       ~            parsed as US-ASCII.
       ~ UTF8Type: A string encoded as UTF8
       ~ LongType: A 64bit long
       ~ LexicalUUIDType: A 128bit UUID, compared lexically (by byte value)
       ~ TimeUUIDType: a 128bit version 1 UUID, compared by timestamp
       ~
       ~ (To get the closest approximation to 0.3-style supercolumns, you
       ~ would use CompareWith=UTF8Type CompareSubcolumnsWith=LongType.)
       ~
       ~ An optional `Comment` attribute may be used to attach additional
       ~ human-readable information about the column family to its definition.
       ~ 
       ~ The optional KeysCached attribute specifies
       ~ the number of keys per sstable whose locations we keep in
       ~ memory in "mostly LRU" order.  (JUST the key locations, NOT any
       ~ column values.) Specify a fraction (value less than 1), a percentage
       ~ (ending in a % sign) or an absolute number of keys to cache.
       ~ KeysCached defaults to 200000 keys.
       ~
       ~ The optional RowsCached attribute specifies the number of rows
       ~ whose entire contents we cache in memory. Do not use this on
       ~ ColumnFamilies with large rows, or ColumnFamilies with high write:read
       ~ ratios. Specify a fraction (value less than 1), a percentage (ending in
       ~ a % sign) or an absolute number of rows to cache. 
       ~ RowsCached defaults to 0, i.e., row cache is off by default.
       ~ 
       ~ Row and key caches may also be saved periodically; if so, the last-
       ~ saved cache will be loaded in at server start.  By default, cache
       ~ saving is off.
       ~
       ~ Remember, when using caches as a percentage, they WILL grow with
       ~ your data set!
      -->

<Keyspaces>

<!-- DEFAULT KEYSPACE -->
   <Keyspace Name="Keyspace1">
      <ColumnFamily Name="Standard1" CompareWith="BytesType"
                    KeysCached="1000"
                    RowsCached="100"
                    RowCacheSavePeriodInSeconds="0"
                    KeyCacheSavePeriodInSeconds="3600"/>
      <ColumnFamily Name="Standard2" 
                    CompareWith="UTF8Type"
                    KeysCached="100%"/>
      <ColumnFamily Name="StandardByUUID1" CompareWith="TimeUUIDType" />
      <ColumnFamily Name="Super1"
                    ColumnType="Super"
                    CompareWith="BytesType"
                    CompareSubcolumnsWith="BytesType" />
      <ColumnFamily Name="Super2"
                    ColumnType="Super"
                    CompareWith="UTF8Type"
                    CompareSubcolumnsWith="UTF8Type"
                    RowsCached="10000"
                    KeysCached="50%"
                    Comment="A column family with supercolumns, whose column and subcolumn names are UTF8 strings"/>

      <!--
       ~ Strategy: The class that extends AbstractReplicationStrategy 
       ~ determines how replicas are placed around the token ring.
       ~ Out of the box, Cassandra provides
       ~ org.apache.cassandra.locator.RackUnawareStrategy and
       ~ org.apache.cassandra.locator.RackAwareStrategy (place one replica in
       ~ a different datacenter, and the others on different racks in the same
       ~ one.)
      -->
      <ReplicaPlacementStrategy>org.apache.cassandra.locator.RackUnawareStrategy</ReplicaPlacementStrategy>

      <!-- Number of replicas of the data -->
      <ReplicationFactor>1</ReplicationFactor>

      <!--
       ~ EndPointSnitch: Setting this to the class that implements
       ~ AbstractEndpointSnitch, which lets Cassandra know enough
       ~ about your network topology to route requests efficiently.
       ~ Out of the box, Cassandra provides org.apache.cassandra.locator.EndPointSnitch,
       ~ and PropertyFileEndPointSnitch is available in contrib/.
      -->
      <EndPointSnitch>org.apache.cassandra.locator.EndPointSnitch</EndPointSnitch>      
   </Keyspace>

<!-- TESTING KEYSPACE -->
   <Keyspace Name="Testing">
      <!-- COLUMN -->
      <ColumnFamily Name="Users" CompareWith="BytesType"
                    KeysCached="1000"
                    RowsCached="100"
                    RowCacheSavePeriodInSeconds="0"
                    KeyCacheSavePeriodInSeconds="3600"/>
      <ColumnFamily Name="Networking" CompareWith="BytesType"
                    KeysCached="1000"
                    RowsCached="100"
                    RowCacheSavePeriodInSeconds="0"
                    KeyCacheSavePeriodInSeconds="3600"/>
      <ColumnFamily Name="Trips" CompareWith="BytesType"
                    KeysCached="1000"
                    RowsCached="100"
                    RowCacheSavePeriodInSeconds="0"
                    KeyCacheSavePeriodInSeconds="3600"/>
      <ColumnFamily Name="Services" CompareWith="BytesType"
                    KeysCached="1000"
                    RowsCached="100"
                    RowCacheSavePeriodInSeconds="0"
                    KeyCacheSavePeriodInSeconds="3600"/>
      <!-- SUPERCOLUMN -->
      <ColumnFamily Name="myTransport"
                    ColumnType="Super"
                    CompareWith="BytesType"
                    CompareSubcolumnsWith="BytesType" />
      <ColumnFamily Name="Reputation"
                    ColumnType="Super"
                    CompareWith="BytesType"
                    CompareSubcolumnsWith="BytesType" />

      <!--
       ~ Strategy: The class that extends AbstractReplicationStrategy 
       ~ determines how replicas are placed around the token ring.
       ~ Out of the box, Cassandra provides
       ~ org.apache.cassandra.locator.RackUnawareStrategy and
       ~ org.apache.cassandra.locator.RackAwareStrategy (place one replica in
       ~ a different datacenter, and the others on different racks in the same
       ~ one.)
      -->
      <ReplicaPlacementStrategy>org.apache.cassandra.locator.RackUnawareStrategy</ReplicaPlacementStrategy>

      <!-- Number of replicas of the data -->
      <ReplicationFactor>10</ReplicationFactor>

      <!--
       ~ EndPointSnitch: Setting this to the class that implements
       ~ AbstractEndpointSnitch, which lets Cassandra know enough
       ~ about your network topology to route requests efficiently.
       ~ Out of the box, Cassandra provides org.apache.cassandra.locator.EndPointSnitch,
       ~ and PropertyFileEndPointSnitch is available in contrib/.
      -->
      <EndPointSnitch>org.apache.cassandra.locator.EndPointSnitch</EndPointSnitch>
   </Keyspace>

<!-- OTHER KEYSPACE -->

</Keyspaces>




  <!--
   ~ Authenticator: any IAuthenticator may be used, including your own as long
   ~ as it is on the classpath.  Out of the box, Cassandra provides
   ~ org.apache.cassandra.auth.AllowAllAuthenticator and,
   ~ org.apache.cassandra.auth.SimpleAuthenticator 
   ~ (SimpleAuthenticator uses access.properties and passwd.properties by
   ~ default).
   ~
   ~ If you don't specify an authenticator, AllowAllAuthenticator is used.
  -->
  <Authenticator>org.apache.cassandra.auth.AllowAllAuthenticator</Authenticator>

  <!--
   ~ Partitioner: any IPartitioner may be used, including your own as long
   ~ as it is on the classpath.  Out of the box, Cassandra provides
   ~ org.apache.cassandra.dht.RandomPartitioner,
   ~ org.apache.cassandra.dht.OrderPreservingPartitioner, and
   ~ org.apache.cassandra.dht.CollatingOrderPreservingPartitioner.
   ~ (CollatingOPP colates according to EN,US rules, not naive byte
   ~ ordering.  Use this as an example if you need locale-aware collation.)
   ~ Range queries require using an order-preserving partitioner.
   ~
   ~ Achtung!  Changing this parameter requires wiping your data
   ~ directories, since the partitioner can modify the sstable on-disk
   ~ format.
  -->
  <Partitioner>org.apache.cassandra.dht.RandomPartitioner</Partitioner>

  <!--
   ~ You should always specify InitialToken when setting up a production
   ~ cluster for the first time, and often when adding capacity later.
   ~ The principle is that each node should be given an equal slice of
   ~ the token ring; see http://wiki.apache.org/cassandra/Operations
   ~ for more details.
   ~
   ~ If blank, Cassandra will request a token bisecting the range of
   ~ the heaviest-loaded existing node.  If there is no load information
   ~ available, such as is the case with a new cluster, it will pick
   ~ a random token, which will lead to hot spots.
  -->
  <InitialToken></InitialToken>

  <!--
   ~ Directories: Specify where Cassandra should store different data on
   ~ disk.  Keep the data disks and the CommitLog disks separate for best
   ~ performance
  -->
  <SavedCachesDirectory>/var/lib/cassandra/saved_caches</SavedCachesDirectory>
  <CommitLogDirectory>/var/log/cassandra/commitlog</CommitLogDirectory>
  <DataFileDirectories>
      <DataFileDirectory>/var/lib/cassandra/data</DataFileDirectory>
  </DataFileDirectories>


  <!--
   ~ Addresses of hosts that are deemed contact points. Cassandra nodes
   ~ use this list of hosts to find each other and learn the topology of
   ~ the ring. You must change this if you are running multiple nodes!
  -->
  <Seeds>
        <Seed>127.0.0.1</Seed>
  </Seeds>


  <!-- Miscellaneous -->

  <!-- Time to wait for a reply from other nodes before failing the command -->
  <RpcTimeoutInMillis>10000</RpcTimeoutInMillis>
  <!-- phi value that must be reached before a host is marked as down.
       most users should never adjust this -->
  <!-- PhiConvictThreshold>8</PhiConvictThreshold -->
  <!-- Size to allow commitlog to grow to before creating a new segment -->
  <CommitLogRotationThresholdInMB>128</CommitLogRotationThresholdInMB>

